{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Readme","text":"<p>MDTC - Model-driven TOML Configuration.</p> <p>A lightweight config singleton meant for storing your application's config state no matter where or how many times it is instantiated. You can pass this object around across your entire app and not worry about config mutations, unvalidated config values or lack of IDE completions. Originally meant for use with TOML key/value-based configs, but any k/v object should work as long as it complies with the model.</p> <p>The source documentation can be found here</p>"},{"location":"#what-is-mdtc-for","title":"What is MDTC for?","text":"<ul> <li>Avoids having to use or chain <code>.get()</code> or retrieve config values via <code>cfg[\"foo\"][\"bar\"][\"baz\"]</code>.</li> <li>Code-completion-friendly via model-driven approach.</li> <li>Custom configuration validation (either via Pydantic's interfaces or custom-built validators you define).</li> <li>Immutable config state support. The config itself is immutable by default - you cannot replace <code>config.foo</code> with another value, for instance.</li> <li>Supports nicer type hints instead of a huge TypeDict or another approach for a config dictionary loaded into Python.</li> </ul>"},{"location":"#what-mdtc-is-not-for","title":"What MDTC is not for","text":"<ul> <li>It is not meant to replace other methods of loading TOML or dict configs, it simply provides an alternative for housing your TOML config values.</li> <li>It is not meant as \"less code\". The guarantees it provides require a different implementation approach, and won't always result in less upfront code.</li> <li>Codebases using other approaches or small configs won't benefit from this approach as much.</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>None, just the Python standard library.</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#simple-configuration","title":"Simple Configuration","text":"main.py<pre><code>import tomllib # python3.11-only, use tomli for &lt;=3.10\nfrom dataclasses import dataclass\nfrom mdtc import Config\n@dataclass\nclass FooCfg:\nfoo: str\nbar: str\n_name: str = \"misc\"\n_key: str = \"config.misc\"\nclass MyConf(Config):\nmisc: FooCfg\ncfg = \"\"\"\n[config.misc]\nfoo=\"bar\"\nbar=\"baz\"\n\"\"\"\ntoml = tomllib.loads(cfg)\nconfig = MyConf(toml)\n</code></pre>"},{"location":"#pydantic-models-in-your-configuration","title":"Pydantic Models in your Configuration","text":"main.py<pre><code>import tomllib # python3.11-only, use tomli for &lt;=3.10\nfrom pydantic import BaseModel\nfrom mdtc import Config\nclass FooCfg(BaseModel):\n_name: str = \"misc\"\n_key: str = \"config.misc\"\nfoo: str\nbar: str\nclass MyConf(Config):\nmisc: FooCfg\ncfg = \"\"\"\n[config.misc]\nfoo=\"bar\"\nbar=\"baz\"\n\"\"\"\ntoml = tomllib.loads(cfg)\nconfig = MyConf(toml)\n</code></pre>"},{"location":"#pydantic-dataclass-example","title":"Pydantic <code>dataclass</code> Example","text":"main.py<pre><code>import tomllib # python3.11-only, use tomli for &lt;=3.10\nfrom pydantic import Field, validator\nfrom pydantic.dataclasses import dataclass\nfrom mdtc import Config\n@dataclass\nclass FooCfg:\nfoo: str\nbar: str = Field(title=\"A bar to get drinks in..\")\n_name: str = \"misc\"\n_key: str = \"config.misc\"\n@validator(\"foo\")\ndef name_must_contain_space(cls, v):\nif \" \" in v:\nraise ValueError(\"must NOT contain a space!\")\nreturn v.title()\nclass MyConf(Config):\nmisc: FooCfg\ncfg = \"\"\"\n[config.misc]\nfoo=\"bar\"\nbar=\"baz\"\n\"\"\"\ntoml = tomllib.loads(cfg)\nconfig = MyConf(toml)\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p><code>Coming soon..</code></p>"},{"location":"docs/errors/","title":"Errors","text":""},{"location":"docs/errors/#mdtc.errors.ConfigAttributeError","title":"<code>ConfigAttributeError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Proxy exception for Attribute Errors inside the MDTC Singleton.</p> Source code in <code>mdtc/errors.py</code> <pre><code>class ConfigAttributeError(Exception):\n\"\"\"Proxy exception for Attribute Errors inside the MDTC Singleton.\"\"\"\n</code></pre>"},{"location":"docs/errors/#mdtc.errors.ConfigKeyNotFoundError","title":"<code>ConfigKeyNotFoundError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Proxy exception for config object Key Errors inside the MDTC Singleton.</p> Source code in <code>mdtc/errors.py</code> <pre><code>class ConfigKeyNotFoundError(Exception):\n\"\"\"Proxy exception for config object Key Errors inside the MDTC Singleton.\"\"\"\n</code></pre>"},{"location":"docs/errors/#mdtc.errors.FrozenConfigException","title":"<code>FrozenConfigException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Proxy exception for immutablility raises.</p> Source code in <code>mdtc/errors.py</code> <pre><code>class FrozenConfigException(Exception):\n\"\"\"Proxy exception for immutablility raises.\"\"\"\n</code></pre>"},{"location":"docs/mdtc/","title":"Mdtc","text":""},{"location":"docs/mdtc/#mdtc--a-model-driven-singleton-for-storing-toml-or-another-dict-based-configuration","title":"A model-driven singleton for storing TOML or another dict-based configuration.","text":"<p>Defines a Config class which is to be used for inheriting from. In order to maintain a single configuration instance across your entire application state, this class will enforce a singleton pattern which ensures that multiple instantiations of the parent class which inherits from Config will result in the same class instance.</p> <p>Moreover, it allows the user to define the structure of their configuration via models, which, out of the box - can be classes, dataclasses or Pydantic models. Practically anything that can be instantiated and implements attribute getters and setters should work as a configuration definition.</p>"},{"location":"docs/mdtc/#mdtc.Config","title":"<code>Config</code>","text":"<p>         Bases: <code>Singleton</code></p> <p>Ensures that only on instance of your configuration is present in your application.</p> <p>At the same time, it enforces a pattern of defining your configuration via model-driven approach, where each key is a pre-defined and pre-typed model of your configuration.</p> Source code in <code>mdtc/__init__.py</code> <pre><code>class Config(Singleton):\n\"\"\"\n    Ensures that only on instance of your configuration is present in your application.\n    At the same time, it enforces a pattern of defining your configuration via model-driven\n    approach, where each key is a pre-defined and pre-typed model of your configuration.\n    \"\"\"\n__isfrozen: bool = False\ndef __init__(self, config_object: dict[str, Any]) -&gt; None:\n\"\"\"\n        Initialise the configuration class using a file path and models.\n        Args:\n            config_object (dict[str, Any]): The config dict (`toml` or other).\n        Raises:\n            ConfigAttributeError: Raised when a model `_name` does not match the attribute\n            defined inside your configuration class.\n            ConfigKeyNotFoundError: Raised when a `_key` defined in the model is not found\n            in the configuration object.\n        \"\"\"\n# Because defining a model in the config for typing purposes does not define a\n# default value (and should not!), we use `get_type_hints` to retrieve this\n# from the child class and check against what the model would have defined.\ntry:\nannotations = get_type_hints(self)\nexcept TypeError:\nraise Exception(\"No configs defined!\")\nbases = [(name, cls_) for name, cls_ in annotations.items() if self.__implements_cfg(cls_)]\nif not bases:\nraise Exception(\"Configuration empty!\")\nfor name, base in bases:\nif name != base._name:\nraise ConfigAttributeError(\nf\"The model - `{base.__name__}` says it's confobj key name is - `{base._name}`,\"\n+ f\" but it has been declared as `{name}` inside `{self.__class__.__name__}`!\"\n)\nif not (conf_dict := self.__get_cfg(base._key, config_object)):\nraise ConfigKeyNotFoundError(\nf\"The model - `{base.__name__}` asked to load a key - `{base._key}`\"\n+ \" however the configuration does not contain such a key!\"\n)\n# Let the model throw own error on instantiation..\nself.__setattr__(base._name, base(**conf_dict))\n# Freeze the class instance\nself.__isfrozen = True\ndef __setattr__(self, attr: str, value: Any) -&gt; None:\nif self.__isfrozen:\nraise FrozenConfigException(\"Can't mutate the config!\")\nsuper().__setattr__(attr, value)\n@staticmethod\ndef __implements_cfg(class_: Any) -&gt; bool:\n\"\"\"Check if a given class uses `_key` and `_name` attributes as this class expects.\"\"\"\nreturn hasattr(class_, \"_key\") and hasattr(class_, \"_name\")\n@staticmethod\ndef __get_cfg(key: str, cfg: dict[str, Any]) -&gt; Any:\n\"\"\"\n        Deep \"get\" from a n-depth dictionary using a TOML notation key ([A.B..]).\n        Args:\n            key (str): The TOML key for where the configuration is housed.\n            cfg (dict[str, Any]): The dictionary passed in to the config class.\n        Returns:\n            Any: An applicable ANY-type value or None if key is not found.\n        \"\"\"\nreducer: Callable[..., Any] = lambda dict_, key: dict_.get(key) if dict_ else None\nreturn reduce(reducer, key.split(\".\"), cfg)\ndef __repr__(self) -&gt; str:\nreturn f\"&lt;{self.__class__.__name__}(hash={self.__hash__()})&gt;\"\n</code></pre>"},{"location":"docs/mdtc/#mdtc.Config.__get_cfg","title":"<code>__get_cfg(key, cfg)</code>  <code>staticmethod</code>","text":"<p>Deep \"get\" from a n-depth dictionary using a TOML notation key ([A.B..]).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The TOML key for where the configuration is housed.</p> required <code>cfg</code> <code>dict[str, Any]</code> <p>The dictionary passed in to the config class.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>An applicable ANY-type value or None if key is not found.</p> Source code in <code>mdtc/__init__.py</code> <pre><code>@staticmethod\ndef __get_cfg(key: str, cfg: dict[str, Any]) -&gt; Any:\n\"\"\"\n    Deep \"get\" from a n-depth dictionary using a TOML notation key ([A.B..]).\n    Args:\n        key (str): The TOML key for where the configuration is housed.\n        cfg (dict[str, Any]): The dictionary passed in to the config class.\n    Returns:\n        Any: An applicable ANY-type value or None if key is not found.\n    \"\"\"\nreducer: Callable[..., Any] = lambda dict_, key: dict_.get(key) if dict_ else None\nreturn reduce(reducer, key.split(\".\"), cfg)\n</code></pre>"},{"location":"docs/mdtc/#mdtc.Config.__implements_cfg","title":"<code>__implements_cfg(class_)</code>  <code>staticmethod</code>","text":"<p>Check if a given class uses <code>_key</code> and <code>_name</code> attributes as this class expects.</p> Source code in <code>mdtc/__init__.py</code> <pre><code>@staticmethod\ndef __implements_cfg(class_: Any) -&gt; bool:\n\"\"\"Check if a given class uses `_key` and `_name` attributes as this class expects.\"\"\"\nreturn hasattr(class_, \"_key\") and hasattr(class_, \"_name\")\n</code></pre>"},{"location":"docs/mdtc/#mdtc.Config.__init__","title":"<code>__init__(config_object)</code>","text":"<p>Initialise the configuration class using a file path and models.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>dict[str, Any]</code> <p>The config dict (<code>toml</code> or other).</p> required <p>Raises:</p> Type Description <code>ConfigAttributeError</code> <p>Raised when a model <code>_name</code> does not match the attribute</p> <code>ConfigKeyNotFoundError</code> <p>Raised when a <code>_key</code> defined in the model is not found</p> Source code in <code>mdtc/__init__.py</code> <pre><code>def __init__(self, config_object: dict[str, Any]) -&gt; None:\n\"\"\"\n    Initialise the configuration class using a file path and models.\n    Args:\n        config_object (dict[str, Any]): The config dict (`toml` or other).\n    Raises:\n        ConfigAttributeError: Raised when a model `_name` does not match the attribute\n        defined inside your configuration class.\n        ConfigKeyNotFoundError: Raised when a `_key` defined in the model is not found\n        in the configuration object.\n    \"\"\"\n# Because defining a model in the config for typing purposes does not define a\n# default value (and should not!), we use `get_type_hints` to retrieve this\n# from the child class and check against what the model would have defined.\ntry:\nannotations = get_type_hints(self)\nexcept TypeError:\nraise Exception(\"No configs defined!\")\nbases = [(name, cls_) for name, cls_ in annotations.items() if self.__implements_cfg(cls_)]\nif not bases:\nraise Exception(\"Configuration empty!\")\nfor name, base in bases:\nif name != base._name:\nraise ConfigAttributeError(\nf\"The model - `{base.__name__}` says it's confobj key name is - `{base._name}`,\"\n+ f\" but it has been declared as `{name}` inside `{self.__class__.__name__}`!\"\n)\nif not (conf_dict := self.__get_cfg(base._key, config_object)):\nraise ConfigKeyNotFoundError(\nf\"The model - `{base.__name__}` asked to load a key - `{base._key}`\"\n+ \" however the configuration does not contain such a key!\"\n)\n# Let the model throw own error on instantiation..\nself.__setattr__(base._name, base(**conf_dict))\n# Freeze the class instance\nself.__isfrozen = True\n</code></pre>"},{"location":"docs/singleton/","title":"Singleton","text":"<p>MDTC Singleton module.</p>"},{"location":"docs/singleton/#mdtc.singleton.Singleton","title":"<code>Singleton</code>","text":"<p>Simplistic singleton-pattern class to inherit from.</p> <p>Best used for when you require only a single instance of a specific class to ever be allowed to exist in your program.</p> Source code in <code>mdtc/singleton.py</code> <pre><code>class Singleton:\n\"\"\"\n    Simplistic singleton-pattern class to inherit from.\n    Best used for when you require only a single instance of a specific class\n    to ever be allowed to exist in your program.\n    \"\"\"\ndef __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Singleton\":\n\"\"\"\n        Intercept the `__new__` call and return an existing instance of this class instead.\n        \"\"\"\nif not hasattr(cls, \"instance\"):\ncls.instance = super(Singleton, cls).__new__(cls)\nreturn cls.instance\n@classmethod\ndef clear_instance(cls) -&gt; None:\n\"\"\"Destroys current instance and re-sets the singleton.\"\"\"\ndel cls.instance\n</code></pre>"},{"location":"docs/singleton/#mdtc.singleton.Singleton.__new__","title":"<code>__new__(*args, **kwargs)</code>","text":"<p>Intercept the <code>__new__</code> call and return an existing instance of this class instead.</p> Source code in <code>mdtc/singleton.py</code> <pre><code>def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Singleton\":\n\"\"\"\n    Intercept the `__new__` call and return an existing instance of this class instead.\n    \"\"\"\nif not hasattr(cls, \"instance\"):\ncls.instance = super(Singleton, cls).__new__(cls)\nreturn cls.instance\n</code></pre>"},{"location":"docs/singleton/#mdtc.singleton.Singleton.clear_instance","title":"<code>clear_instance()</code>  <code>classmethod</code>","text":"<p>Destroys current instance and re-sets the singleton.</p> Source code in <code>mdtc/singleton.py</code> <pre><code>@classmethod\ndef clear_instance(cls) -&gt; None:\n\"\"\"Destroys current instance and re-sets the singleton.\"\"\"\ndel cls.instance\n</code></pre>"}]}